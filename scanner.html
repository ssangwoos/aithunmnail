<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>HTML5 ìŠ¤ìºë„ˆ (ì„¤ì¹˜ í•„ìš” ì—†ìŒ)</title>
    <style>
        body { font-family: sans-serif; background: #f0f2f6; text-align: center; padding: 20px; }
        h1 { color: #333; }
        .container { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        canvas { border: 2px solid #ddd; background: white; cursor: crosshair; max-width: 100%; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .controls { margin: 10px 0; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #ff4b4b; color: white; border: none; border-radius: 5px; }
        button:hover { background: #ff2b2b; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input[type="file"] { padding: 10px; }
        .status { color: #666; font-weight: bold; margin-bottom: 10px; }
    </style>
</head>
<body>

    <h1>ğŸ“± ì´ˆê°„ë‹¨ ì›¹ ìŠ¤ìºë„ˆ (HTML5)</h1>
    <p>íŒŒì´ì¬, ì„œë²„, ì„¤ì¹˜ ë‹¤ í•„ìš” ì—†ìŠµë‹ˆë‹¤. ê·¸ëƒ¥ ì“°ì„¸ìš”.</p>

    <div class="container">
        <input type="file" id="uploadInput" accept="image/*">
        <div class="status" id="statusMsg">ì‚¬ì§„ì„ ì˜¬ë¦¬ê³  ëª¨ì„œë¦¬ 4ê°œë¥¼ ì°ìœ¼ì„¸ìš” (ì¢Œìƒâ†’ìš°ìƒâ†’ìš°í•˜â†’ì¢Œí•˜ ìˆœì„œ)</div>
        
        <canvas id="srcCanvas"></canvas>
        
        <div class="controls">
            <button id="resetBtn">ğŸ”„ ë‹¤ì‹œ ì°ê¸°</button>
            <button id="downloadBtn" style="display:none; background-color: #00cc00;">ğŸ’¾ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ</button>
        </div>

        <canvas id="dstCanvas" style="display:none;"></canvas>
    </div>

<script>
    const uploadInput = document.getElementById('uploadInput');
    const srcCanvas = document.getElementById('srcCanvas');
    const dstCanvas = document.getElementById('dstCanvas');
    const ctx = srcCanvas.getContext('2d');
    const statusMsg = document.getElementById('statusMsg');
    const resetBtn = document.getElementById('resetBtn');
    const downloadBtn = document.getElementById('downloadBtn');

    let img = new Image();
    let points = []; // ì°ì€ ì ë“¤ ì €ì¥

    // 1. ì´ë¯¸ì§€ ì—…ë¡œë“œ
    uploadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            img.onload = () => {
                // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • (í™”ë©´ì— ë§ê²Œ ì¤„ì´ê¸°)
                const maxWidth = 800;
                const scale = Math.min(1, maxWidth / img.width);
                srcCanvas.width = img.width * scale;
                srcCanvas.height = img.height * scale;
                
                // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                ctx.drawImage(img, 0, 0, srcCanvas.width, srcCanvas.height);
                points = []; // ì  ì´ˆê¸°í™”
                statusMsg.innerText = "ëª¨ì„œë¦¬ 4ê°œë¥¼ ìˆœì„œëŒ€ë¡œ í´ë¦­í•˜ì„¸ìš” (ì™¼ìª½ìœ„ â†’ ì˜¤ë¥¸ìª½ìœ„ â†’ ì˜¤ë¥¸ìª½ì•„ë˜ â†’ ì™¼ìª½ì•„ë˜)";
                downloadBtn.style.display = 'none';
            }
            img.src = event.target.result;
        }
        reader.readAsDataURL(file);
    });

    // 2. ì  ì°ê¸° (í´ë¦­ ì´ë²¤íŠ¸)
    srcCanvas.addEventListener('mousedown', (e) => {
        if(points.length >= 4) return;

        const rect = srcCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        points.push({x, y});

        // ì  ê·¸ë¦¬ê¸° (ì‹œê°í™”)
        ctx.fillStyle = '#00FF00';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();

        // ì„  ì—°ê²°
        if(points.length > 1) {
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(points[points.length-2].x, points[points.length-2].y);
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        // 4ê°œ ë‹¤ ì°ì—ˆìœ¼ë©´ ë³€í™˜ ì‹¤í–‰
        if(points.length === 4) {
            // ë§ˆì§€ë§‰ ì„  ì—°ê²°
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(points[0].x, points[0].y);
            ctx.stroke();
            
            statusMsg.innerText = "ë³€í™˜ ì¤‘...";
            setTimeout(processImage, 100); // UI ë Œë”ë§ì„ ìœ„í•´ ì‚´ì§ ëŒ€ê¸°
        }
    });

    // 3. ë‹¤ì‹œ ì°ê¸° ë²„íŠ¼
    resetBtn.addEventListener('click', () => {
        if(img.src) {
            ctx.drawImage(img, 0, 0, srcCanvas.width, srcCanvas.height);
            points = [];
            statusMsg.innerText = "ë‹¤ì‹œ ì°ì–´ì£¼ì„¸ìš”.";
            downloadBtn.style.display = 'none';
            dstCanvas.style.display = 'none';
        }
    });

    // 4. ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
    downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'scan_result.png';
        link.href = dstCanvas.toDataURL();
        link.click();
    });

    // === í•µì‹¬: íˆ¬ì‹œ ë³€í™˜ ë¡œì§ (ìˆ˜í•™ ê³„ì‚°) ===
    function processImage() {
        // ì›ë³¸ ì¢Œí‘œ
        const srcPoints = points.map(p => p.x * (img.width / srcCanvas.width)); // ì›ë³¸ í•´ìƒë„ë¡œ ì¢Œí‘œ ë³µì›
        const srcFlat = [
            srcPoints[0].x, srcPoints[0].y,
            srcPoints[1].x, srcPoints[1].y,
            srcPoints[2].x, srcPoints[2].y,
            srcPoints[3].x, srcPoints[3].y
        ];

        // ëª©í‘œ ë„ˆë¹„/ë†’ì´ ê³„ì‚°
        const w1 = Math.hypot(srcPoints[1].x - srcPoints[0].x, srcPoints[1].y - srcPoints[0].y);
        const w2 = Math.hypot(srcPoints[2].x - srcPoints[3].x, srcPoints[2].y - srcPoints[3].y);
        const h1 = Math.hypot(srcPoints[3].x - srcPoints[0].x, srcPoints[3].y - srcPoints[0].y);
        const h2 = Math.hypot(srcPoints[2].x - srcPoints[1].x, srcPoints[2].y - srcPoints[1].y);
        
        const dstWidth = Math.max(w1, w2);
        const dstHeight = Math.max(h1, h2);

        // ê²°ê³¼ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        dstCanvas.width = dstWidth;
        dstCanvas.height = dstHeight;
        const dstCtx = dstCanvas.getContext('2d');
        const dstImgData = dstCtx.createImageData(dstWidth, dstHeight);

        // í˜¸ëª¨ê·¸ë˜í”¼ í–‰ë ¬ ê³„ì‚° (OpenCV ì—†ì´ ìˆœìˆ˜ ìˆ˜í•™ìœ¼ë¡œ êµ¬í˜„)
        const h = solveHomography(srcFlat, [0, 0, dstWidth, 0, dstWidth, dstHeight, 0, dstHeight]);

        // í”½ì…€ ë§¤í•‘ (Inverse Mapping)
        const srcData = (function() {
            // ì›ë³¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë©”ëª¨ë¦¬ íš¨ìœ¨ì„ ìœ„í•´ ì„ì‹œ ìº”ë²„ìŠ¤ ì‚¬ìš©)
            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = img.width;
            tmpCanvas.height = img.height;
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCtx.drawImage(img, 0, 0);
            return tmpCtx.getImageData(0, 0, img.width, img.height);
        })();

        // ëª¨ë“  í”½ì…€ì„ ëŒë©´ì„œ ë³€í™˜ (ì—¬ê¸°ê°€ í•µì‹¬)
        const data = dstImgData.data;
        const sData = srcData.data;
        const sw = srcData.width;
        const sh = srcData.height;

        for(let y = 0; y < dstHeight; y++) {
            for(let x = 0; x < dstWidth; x++) {
                // ì—­ë³€í™˜ í–‰ë ¬ ì ìš©
                const den = h[6]*x + h[7]*y + 1;
                const u = (h[0]*x + h[1]*y + h[2]) / den;
                const v = (h[3]*x + h[4]*y + h[5]) / den;

                // ë²”ìœ„ ì²´í¬
                if(u >= 0 && u < sw-1 && v >= 0 && v < sh-1) {
                    const idx = (y * dstWidth + x) * 4;
                    const su = Math.floor(u);
                    const sv = Math.floor(v);
                    const sIdx = (sv * sw + su) * 4;

                    // ë‹¨ìˆœ ë³µì‚¬ (Nearest Neighbor) - ì†ë„ ë¹ ë¦„
                    data[idx] = sData[sIdx];     // R
                    data[idx+1] = sData[sIdx+1]; // G
                    data[idx+2] = sData[sIdx+2]; // B
                    data[idx+3] = 255;           // A
                }
            }
        }

        dstCtx.putImageData(dstImgData, 0, 0);
        
        // ê²°ê³¼ ë³´ì—¬ì£¼ê¸°
        dstCanvas.style.display = 'block';
        dstCanvas.style.maxWidth = '100%';
        statusMsg.innerText = "ì™„ë£Œ! ì•„ë˜ ì´ˆë¡ìƒ‰ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì €ì¥í•˜ì„¸ìš”.";
        downloadBtn.style.display = 'inline-block';
        
        // ìŠ¤í¬ë¡¤ ë‚´ë ¤ì£¼ê¸°
        dstCanvas.scrollIntoView({behavior: "smooth"});
    }

    // 8ê°œì˜ ì ìœ¼ë¡œ í˜¸ëª¨ê·¸ë˜í”¼ í–‰ë ¬(3x3)ì„ êµ¬í•˜ëŠ” í•¨ìˆ˜ (ê°€ìš°ìŠ¤ ì†Œê±°ë²•)
    function solveHomography(src, dst) {
        let a = [];
        for(let i=0; i<4; i++) {
            let sx = src[i*2], sy = src[i*2+1];
            let dx = dst[i*2], dy = dst[i*2+1];
            a.push([sx, sy, 1, 0, 0, 0, -dx*sx, -dx*sy, dx]);
            a.push([0, 0, 0, sx, sy, 1, -dy*sx, -dy*sy, dy]);
        }
        
        // ê°€ìš°ìŠ¤ ì†Œê±°ë²•ìœ¼ë¡œ í•´ êµ¬í•˜ê¸°
        const n = 8;
        for(let i=0; i<n; i++) {
            let maxEl = Math.abs(a[i][i]);
            let maxRow = i;
            for(let k=i+1; k<n; k++) {
                if(Math.abs(a[k][i]) > maxEl) {
                    maxEl = Math.abs(a[k][i]);
                    maxRow = k;
                }
            }
            for(let k=i; k<n+1; k++) {
                let tmp = a[maxRow][k];
                a[maxRow][k] = a[i][k];
                a[i][k] = tmp;
            }
            for(let k=i+1; k<n; k++) {
                let c = -a[k][i] / a[i][i];
                for(let j=i; j<n+1; j++) {
                    if(i===j) a[k][j] = 0;
                    else a[k][j] += c * a[i][j];
                }
            }
        }
        let x = new Array(n).fill(0);
        for(let i=n-1; i>=0; i--) {
            x[i] = a[i][n] / a[i][i];
            for(let k=i-1; k>=0; k--) a[k][n] -= a[k][i] * x[i];
        }
        return [...x, 1];
    }
</script>
</body>
</html>